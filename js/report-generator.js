import { Utils } from './utils.js';

// PDF report generation and formatting
export const ReportGenerator = {
    async generateReport() {
        const meetingTypeSelect = document.getElementById('meetingTypeSelect');
        const methodologySelect = document.getElementById('methodologySelect');
        const industrySelect = document.getElementById('industrySelect');
        
        if (!window.appState.currentFile) {
            alert('Please upload a file first!');
            return;
        }

        const meetingType = meetingTypeSelect?.value || '';
        const methodology = methodologySelect?.value || '';
        const industry = industrySelect?.value || '';
        const selectedOptions = Utils.getSelectedOptions();

        this.generatePDF(meetingType, methodology, industry, selectedOptions, window.appState.currentFile.name);
    },

    generatePDF(meetingType, methodology, industry, selectedOptions, fileName) {
        if (!window.jsPDF) {
            console.error('jsPDF library not loaded');
            return;
        }

        try {
            const { jsPDF } = window;
            const doc = new jsPDF();

            // Set up fonts and styling
            const pageWidth = doc.internal.pageSize.width;
            const margin = 20;
            const lineHeight = 7;
            let y = 30;

            // Helper function to add text with word wrapping
            const addText = (text, fontSize = 12, fontStyle = 'normal', maxWidth = pageWidth - 2 * margin) => {
                doc.setFontSize(fontSize);
                doc.setFont('helvetica', fontStyle);
                const textLines = doc.splitTextToSize(text, maxWidth);
                doc.text(textLines, margin, y);
                y += textLines.length * lineHeight + 5;
                return y;
            };

            // Helper function to check for page break
            const checkPageBreak = (neededSpace = 30) => {
                if (y > doc.internal.pageSize.height - neededSpace) {
                    doc.addPage();
                    y = 30;
                }
            };

            // Title
            doc.setFillColor(99, 102, 241);
            doc.rect(0, 0, pageWidth, 25, 'F');
            doc.setTextColor(255, 255, 255);
            doc.setFontSize(20);
            doc.setFont('helvetica', 'bold');
            doc.text('Meeting Intelligence Report', margin, 16);

            // Reset text color
            doc.setTextColor(0, 0, 0);
            y = 40;

            // Document Information
            addText('Document Information', 16, 'bold');
            addText(`Source File: ${fileName}`, 12, 'normal');
            addText(`Generated: ${Utils.formatDate(new Date())}`, 12, 'normal');
            y += 10;

            checkPageBreak();

            // Meeting Configuration
            addText('Meeting Configuration', 14, 'bold');
            const config = [
                { label: 'Meeting Type', value: this.getMeetingTypeLabel(meetingType) },
                { label: 'Methodology', value: this.getMethodologyLabel(methodology) },
                { label: 'Industry', value: this.getIndustryLabel(industry) }
            ];

            config.forEach(item => {
                if (item.value) {
                    addText(`${item.label}: ${item.value}`, 11, 'normal');
                }
            });
            y += 10;

            checkPageBreak();

            // Selected Analysis Options
            if (selectedOptions && selectedOptions.length > 0) {
                addText('Analysis Focus Areas', 14, 'bold');
                selectedOptions.forEach(option => {
                    checkPageBreak();
                    addText(`â€¢ ${option.title}`, 11, 'bold');
                    if (option.description) {
                        addText(`  ${option.description}`, 10, 'normal');
                    }
                });
                y += 10;
            }

            checkPageBreak(100);

            // AI Analysis Results
            if (window.appState.aiResults) {
                addText('AI Analysis Results', 14, 'bold');
                
                // Clean up the AI results text for PDF
                const cleanResults = this.cleanTextForPDF(window.appState.aiResults);
                addText(cleanResults, 11, 'normal');
            } else {
                addText('AI Analysis Results', 14, 'bold');
                addText('No AI analysis results available. Please run the AI analysis first.', 11, 'italic');
            }

            // Footer
            const pageCount = doc.internal.getNumberOfPages();
            for (let i = 1; i <= pageCount; i++) {
                doc.setPage(i);
                doc.setFontSize(8);
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(128, 128, 128);
                doc.text(`Generated by Light Skai Meeting Intelligence Platform`, margin, doc.internal.pageSize.height - 15);
                doc.text(`Page ${i} of ${pageCount}`, pageWidth - margin - 20, doc.internal.pageSize.height - 15);
            }

            // Save the PDF
            const sanitizedFileName = fileName.replace(/\.[^/.]+$/, '').replace(/[^a-zA-Z0-9]/g, '_');
            doc.save(`Meeting_Report_${sanitizedFileName}_${new Date().toISOString().split('T')[0]}.pdf`);

        } catch (error) {
            console.error('PDF generation error:', error);
            alert('Failed to generate PDF report. Please try again.');
        }
    },

    cleanTextForPDF(text) {
        if (!text) return 'No content available.';
        
        return text
            .replace(/<[^>]*>/g, '') // Remove HTML tags
            .replace(/&nbsp;/g, ' ') // Replace HTML entities
            .replace(/&amp;/g, '&')
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/\*\*(.*?)\*\*/g, '$1') // Remove markdown bold
            .replace(/\*(.*?)\*/g, '$1') // Remove markdown italic
            .replace(/#{1,6}\s/g, '') // Remove markdown headers
            .replace(/\n{3,}/g, '\n\n') // Limit consecutive line breaks
            .trim();
    },

    getMeetingTypeLabel(value) {
        if (!value || !window.appState.meetingTypes) return '';
        const type = window.appState.meetingTypes.find(t => t.id == value || t.ID == value);
        return type ? type.Type : value;
    },

    getMethodologyLabel(value) {
        if (!value || !window.appState.frameworks) return '';
        const framework = window.appState.frameworks.find(f => f.id == value || f.ID == value);
        return framework ? framework.Method : value;
    },

    getIndustryLabel(value) {
        if (!value || !window.appState.industries) return '';
        const industry = window.appState.industries.find(i => i.id == value || i.ID == value);
        return industry ? industry.Industry_Name : value;
    }
};